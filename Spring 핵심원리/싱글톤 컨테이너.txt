웹 어플리케이션은 동시간에 다중의 이용자가 서비스를 이용하는 경우가 많다.
이때, 요청이 올때마다 객체가 서로 다른 걸로 여러개가 실행이 되는 경우가 있다. (Spring 없은 순수한 DI 컨테이너)

new 로 새 객체를 매번 생성해주기 때문.

-> 이를 방지하기 위한게 싱글톤? (맞다)
-> 싱글톤 컨테이너를 사용하면 하나의 객체만 생성하고 모든 사용자가 이 Service 객체를 공유하도록 설계하는 것.

## 싱글톤 컨테이너 ##
클래스의 인스턴스가 1개만 생성되는걸 "보장"해주는 것이다.

(구현방법)
1. 미리 private static final [자기 클래스명] [인스턴스명] = new [자기클래스명]();
을 선언해준다.
-> 이부분에서 여러개 선언하면, 여러개 등록이 가능한 것일까?
이러면 static 으로 인해 전체에서 하나만 미리 생성되게 된다.
2. 이후 getter 로 해당 객체를 반환하게 한다.
3. 생성자를 private로 선언하여, 외부에서 new 키워드로 객체를 생성하는 것을 금지한다.

-> 이를 통해 해당 객체의 인스턴스가 1개만 생성되는 것을 "보장" 해줄 수 있다.

(단점)
자식 클래스를 만들기 어렵다 (private)
코드가 길어진다.
DIP위반, OCP 위반 가능성 이 있다.

@@ Spring 을 사용하면, 자동으로 싱글톤으로 객체를 작성해준다.
Bean 을 이용하면 해당 빈 이름과 빈 객체를 미리 생성해 놓는 것을 알 수 있다.

### 싱글톤 방식의 주의점 ###
객체 인스턴스를 하나만 생성해서 공유한다.
-> 상태를 유지하게 설계하면 잘못된 정보를 가져갈 수 있다.
-> 읽기만 가능해야한다.
-> 특정 클라이언트에 의존적인 필드가 있으면 안된다. ( 클라이언트의 정보)
-> 스프링 빈의 필드에 공유 값 설정하면 큰 장애가 발생한다.

만약 해당 객체 인스턴스 안에 사용자에게서 정보를 받아서 "@@저장하는@@" 변수가 있다면...
하나의 객체를 공유하므로 다른 사람이 작성한 정보를 받아올 수도 있다.

결국 읽기만 가능해야한다는 건 사용자가 넣은 정보를 넣어주기만하고,
읽는건 다른 객체 혹은 DB에서 읽어와야한다는 뜻일 것이다.
또는 지역변수 파라미터, ThreadLocal 등 공유되지 않는 변수를 사용해야한다.


결국 작성용지가 여러개 인게 싫어서 태블릿으로 같은 입력양식을 계속 사용하는데,
이전 사용자의 정보는 배제시켜야한다는 뜻.


@Configuration ( 을 사용해야지만 싱글톤이 보장된다. @Bean 만 가지고는 부족, @Autowired를 넣는다면 @Configuration 이 없어도 되기는 한다.)
내부의 
@Bean 에서
여러 서비스에서 새로운 new로 여러 번 호출 되는 경우는 어떻게 되는 걸까?
Spring이 이걸 관리해주는 걸까?
-> 내가 만든 클래스가 아닌, CGLIB 라는 바이트코드 조작 라이브러리를 통해, AppConfig 클래스를 상속받은 다른 임의 클래스를
스프링 빈으로 등록한 것이다.
즉. new을 이용하여 만든 것 말고 지들것 사용한다는 뜻.

%% 주의 %%
@Bean 으로 선언할때
static 이 선언되어 있으면, 싱글톤이 아니라 각기 다른 객체가 반환된다.







