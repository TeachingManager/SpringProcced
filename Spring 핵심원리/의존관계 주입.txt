의존관계 주입에는 여러가지 방법이 있다.

1. 생성자 주입
2. 수정자(setter) 주입
3. 필드 주입
4. 일반 메서드 주입



##############
## 생성자 주입 ##
##############
생성자 위에 @Autowired를 붙여서 DI
생성자 호출 시점에 딱 1번만 호출된다.
-> 불변, 필수(final 로 선언된) 적인 의존관계에서 사용된다.

생성자가 딱 1개만 있다면, @Autowired 를 생략해도 된다.

##############
## 수정자 주입 ##
##############
setter 위에 @Autowired를 붙여서 의존관계를 주입한다.
생성자 주입은 스프린 빈 등록시 자동으로 등록되는데,
수정자 주입은 스프링 빈 두번째 라이프사이클 때 등록된다.

생성자, 수정자 모두 @Autowired 를 붙여도 상관 없다. (싱글톤 보장)

-> 선택적으로 의존관계를 주입할 때 사용한다. @Autowired(required = false) => 선택한 대상이 없어도 오류 X


##############
##  필드  주입  ##
##############
@Autowired 를 private [타입] [인스턴스명]; 으로 작성한다.
간단해 보이나, 외부에서 변경이 불가능해서 테스트하기가 어렵다.
ex) 스프링 빈에 등록시키지 않고 테스트할 경우 setter을 만들지 않는 이상 접근이 불가능하다.

%% 요새에는 거의 쓰지 않는다. %%
스프링 빈 내에서 등록힌 Bean 을 테스트 할때 쓰는 @Autowired 빼고는 거의 이 방법을 사용하지 않는다.

##############
#일반메서드 주입#
##############
어떠한 메서드는 메서드를 만들고 @Autowired 로 의존관계를 주입할 수 있다.
수정자 주입의 상위 단계

%% 일반적으로 거의 쓰지 않는다. %%


---> 테스트에서 누락을 방지 하기 위해 생성자 주입방식을 선택하는 것이 가장 효율적이다.
---> final 을 사용하여 값을 바꿔주지 않게 하기 위해서는 생성자 주입을 넣어야한다.



########### 옵션 처리 ##############
@ Autowired 의 옵션... ex)
 required -> 주입할 대상이 없으면 error 가 아닌 호출이 안된다.
 @Nullable -> 주입할 대상이 없으면 null 로
 @Optional<> -> 주입할 대상이 없으면 Optional.empty 로 반환







########### 롬복 #############
plugin 에서 lombok 을 깔고, gradle 에 설정 추가, Annotation Processors 체크 해주어야한다.

@Getter, @Setter 을 자동으로 만들어준다. 굳이 getName 등을 만들어줄 필요가 없다.

final 이 붙은 요소들로 생성자를 만들어주는 어노테이션도 있다.
@RequireArgsConstructer (ctrl f12 로 확인가능)
위를 적용시킨다면 생성자를 없애야한다.







######## 중복시 ############
의존관계 주입시 해당 인터페이스로 확장한 Bean 이 여러개가 있다면?
타입으로 찾는 특성상 중복 오류가 발생한다.
이를 피하기 위해 수동 등록 방법이 아닌 방법들이 있다.
1. Autowired 필드명 매칭
-> 빈이 여러개 있으면, 파라미터 이름으로 빈 이름으로 매칭한다.

2. @Quilifier 끼리 매칭
-> 추가 구분자. 빈 이름을 변경하는 것은 아니다.
-> 서브 구별자 같은 ....
@Quilifier("mainDiscount") 을 원하는 빈 위에 넣어주고,
수정자, 생성자 에서 파라미터를 넣을 때 인자 앞에 저 @Quilifier("mainDiscount")을 넣어서 지정해준다.
못찾으면, 이름으로 역시 찾는다.

3. @Primary 라는 어노테이션 사용
ctrl alt b
빈 위에 붙여서 하나만 지정해주는 것.


@Quilifier 가 더 상세하므로 @Primary 보다 우선순위가 높음
테스트 결과.. 확인 완료

@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Qualifier("mainDiscountPolicy")
자바 클래스 어노테이션을 생성해서 직접 사용자 지정 어노테이션을 만들 수도 있다. (클래스 안에 내용은 x)

이렇게 한다면, 다른 곳에서 @Quilifier 을 쓸 때 이름을 틀릴 경우 컴파일 오류가 나지 않고, 런타임 에러가 난다.
이때, 직접 만든 어노테이션을 만든다면, 이름을 틀리게 적으면, 컴파일 오류가 나, 에러 체킹하기 더 편리하다.







###### 모든 빈 조회하고 싶을 때 #######
private final Map<String, DiscountPolicy> policyMap;
private final List<DiscountPolicy> policies;

처럼 받을 수 있다.
















