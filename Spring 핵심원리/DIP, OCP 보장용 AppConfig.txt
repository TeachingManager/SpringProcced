지금까지의 코드는
service 내에서 각 memberRepository 가 어떤 class 를 가져오는지 직접 지정해주어야했다.
이는 DIP, OCP 위반이다.


따라 그 지정해주는 걸 AppConfig 를 통해 지정해주어야한다.
그 안에서 지정해주고,
Service 내부에서는 해주지 않는다. 즉 AppCofing 에서 모든 의존관계를 설정한다.

기존의 Service 에서는 대신 생성자를 통해, AppConfig 에서 선언된 기본 생성자로 Memory, DB 등으로 연결된
class 를 파라미터로 받아와서

Service 객체의 생성자로 만들어준다. (의존관계 주입) Dependency Injection D.I 

따라서 간단하게 생가한다면 appconfig 가 생성해주고 그 참조값을 Service 에게 전달해주는 것.

생성 담당자 appconfig 쉨

그리고 모두 작성이 완료되었다면

각 기능 (App) 안에서
Appconfig appConfig = new Appconfig();
로 선언해주고.
기존의 선언을 appconfig.Service(); 로 바꾸어주어야한다.

여기에서도 생성 주입을 의미한다.


Appconfig 도 구성과 기능으로 분할해주기 위해 리팩토링을 해야한다.
리팩토링 한 또 다른 이유는 각각의 역할을 이름으로 명확히 구별하기 위함이다.
한다면, 아래 코드만 변경하면 모든 Service 의  Policy 가 일괄 변경 가능하다.

리펙토링은 생성자의 new 부분을 다시 extract 를 통해 한개로 구현하는 것이다. ctrl alt m

즉 AppConfig 는 전체 역할을 기획하는 기획자.


--------------------- 5가지 적용 

SRP 단일 책임 원칙
-> client 객체 에서 AppConfig 에게 구현 객체 생성 연결 역할을 넘김

DIP 의존관계 역전 원칙
-> 추상화에 의존해야지 구체화에 의존하면 안된다.
-> 클라이언트가 DiscountPolicy 추상화 인터페이스에만 의존할 수 있도록 바꿔주었다.

OCP 
-> 확장에는 열려 있으나, 변경에는 닫혀있다.
-> client 는 할인 정책을 변경하더라도, 클라이언트 코드에 주입하였으므로 코드는 변겨아지 않아도 되었다.
-> 새로운 할인 정책을 추가(확장) 하더라도, 클라이언트 코드를 변경할 필요는 없다.


