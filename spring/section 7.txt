의존관계 주입

생성자 주입
수정자 주입(setter 주입)
필드 주입
일반 메서드 주입


-생성자 주입
생성자 호출 시점에 한번만
불변, 필수 의존관계에 사용
생성자가 한개라면 @Autowired 생락가능

-수정자 주입
선택, 변경 가능성 있는 의존관계에 사용

-필드 주입
DI 프레임워크가 없으면 아무것도 할 수 없다
사용x
실제 코드와 상관없는 테스트코드에서만 사용가능

-일반 메서드 주입
한번에 여러 필드를 주입받을 수 있다
쓸 일이 없다


옵션 처리

@Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
org.springframework.lang.@Nullable : 자동 주입할 대상이 없으면 null이 입력된다. - warning 발생 아마 javax문제?
jakarta.annotation.Nullable 사용?
Optional<> : 자동 주입할 대상이 없으면 Optional.empty 가 입력된다.


생성자 주입을 권장
불변
대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 
오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.(불변해야 한다.)
수정자 주입을 사용하면, setXxx 메서드를 public으로 열어두어야 한다.
누군가 실수로 변경할 수 도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.

final 키워드 사용 가능
생성자에서 값이 설정되지 않는 오류를 컴파일 시점에 막아줌

순수한 자바 언어의 특징을 잘 살리는 방법

생성자 주입을 사용하고 필수 값이 아닌 경우 수정자 주입을 옵션으로 동시에 사용


롬복
@RequiredArgsConstructor 을 사용하면 final 이 붙은 필드의 생성자를 자동으로 만듬

최근에는 생성자를 1개 두고 @Autowired 생략, 롬복 사용


조회 빈이 2개 이상일때

@Autowired 필드 명 매칭
@Qualifier 를 @Qualifier끼리 매칭 - 빈 이름 매칭
@Primary 사용


@Autowired 필드 명 매칭
필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭
private DiscountPolicy rateDiscountPolicy


@Qualifier
추가 구분자를 붙이는 방법
빈 등록시 @Qualifier붙이기
주입시 @Qualifier붙이기

동작 순서
1. @Qualifier끼리 매칭
2. 빈 이름 매칭
3. NoSuchBeanDefinitionException 예외 발생


@Primary 사용
@Primary에 우선순위

@Qualifier가 @Primary보다 우선순위
주로 사용하는것에는 @Primary사용하고 가끔 필요할때 @Qualifier를 사용하여 불러오기



애노테이션 직접 만들기
새로 애노테이션을 만들고 사용하는곳에도 애노테이션 입력



조회한 빈이 모두 필요할 때
Map, List




자동 기능을 기본으로 사용

업무 로직 빈 - 자동
기술 지원 빈 - 수동
애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서
설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다

여러개가 주입될 때 설정정보를 만들어 한눈에 볼 수 있게 하면 좋다
자동으로 하면 특정 패키지에 같이 묶어두는게 좋다

편리한 자동 기능을 기본으로 사용하자
직접 등록하는 기술 지원 객체는 수동 등록
다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자