클라이언트는 인터페이스만 알면 된다
클라이언트가 인터페이스(구현대상)의 내부 구조를 모르더라도 사용 가능
새로운 구조를 만들어도 클라이언트는 배울 필요x
내부 구조가 바뀌더라도 클라이언트에게 영향x
구현 대상을 변경해도 영향 없음

다형성
클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경 가능

인터페이스를 안정적으로 잘 설계하는 것이 중요, 이후 인터페이스의 변화가 없도록

좋은 객체 지향 설계의 5가지 원칙(SOLID)

-SRP 단일 책임 원칙 Single responsibility principle
한 클래스는 하나의 책임만 가져야한다
변경이 있을 때 파급 효과가 적으면 잘 따른 것
범위를 적절하게 잘 조절해야 함

-OCP 개방-폐쇄 원칙 Open/closed principle
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야
새로운 코드를 만들어 확장은 하지만 기존 코드를 변경하지 않아야한다.
구현 객체를 변경하려면 클라이언트 코드를 변경해야 하는 문제
>연관관계를 맺어주는 별도의 조립, 설정자가 필요 ->spring di 컨테이너

-LSP 리스코프 치환 원칙 Liskov substitution principle
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
하위 클래스는 인터페이스 규약을 지켜야한다. (액셀은 앞으로, 뒤로가면x)

-ISP 인터페이스 분리 원칙 Interface segregation principle
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
분리하면 인터페이스가 명확해지고 대체 가능성이 높아진다.

-DIP 의존관계 역전 원칙 Dependency inversion principle *
추상화에 의존해야지, 구체화에 의존하면 안된다
클라이언트가 구현 클래스에 의존하지 않고 인터페이스에 의존해야한다.

다형성 만으로는 OCP, DIP를 지킬 수 없다.

스프링
DI(Dependency Injection) : 의존관계, 의존성 주입
DI 컨테이너 제공

인터페이스를 도입하면 추상화라는 비용 발생
>기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고 향후 필요시 리팩터링해서 인터페이스 도입 가능