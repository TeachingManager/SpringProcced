@Autowired

의존관계를 주입시켜 주는 것이다.


이 @Autowired 는 생성자 위에 적어주면 된다.
또한 생성자가 하나 뿐일 경우 이는 생략 가능하다고 한다.
또, 이 @Autowired 는 컨테이너에 등록된 객체에서만 그 효력을 발휘한다. 컨테이너에 등록되는 방식은 두가지가 있다.


미리 @Service 와 @Repository를 해당 객체 위에 추가해주는 방식이 있다..
이런 방식을 컴포넌트 스캔이라고 한다.
Service 와 Repository 는 컴포넌트의 일종 

이때 중요한 것은 Application 이 등록되어있는 package 안의 component 만 spring 이 스캔한다는 것이다. (기본설정)

또한 @Autowired 를 생성자, Setter 등 다양한 방법으로 넣어서 컨테이너에서 조립할 수 있는데, 
이때 Setter 을 사용하게 된다면 생성 시점이 아닌 다른 시점에서 또 호출되는 불상사가 생길 수 있다. 이를 방지하기 위해 생성자에서 주로 연결해준다.



----------------------------------------------------------------
위와 같이 컴포넌트 스캔이 아닌 방법이 있다. 자바코드로 직접 스프링 빈 을 등록할 수 있다.
이 방식은 상황에 따라 레퍼지토리를 변경해야할 때 이러한 방식을 사용한다고 한다.

예를 들어 지금 인강 진행상황 중 DB 가 정해지지 않아서 MemoryMemberRepository 로 임시로 정해놓았는데,
이때 다른 방식으로 변경해서 interface 로 연결시킨다고 하였을 때, MemoryMemberRepository 를 수정할 필요 없이
새 DBMemberRepository 를 만들어 놓은 뒤 
SpringConfig.java 안의 [222의 interface] 만 바꾸어 놓으면 된다.

모듈화이다....!! 굳

Application 과 같은 level 에 SpringConfig.java 라는 class 파일을 하나 생성해주고
@Configuration 이라는 컴포넌트를 가지고 있는 
public class [이름] {
    @Bean
    public [111] Service(){
        return new Service(Repository());
    }

    @Bean
    public [222] Repository(){
        return new [222의 interface]();
    }
 }



---------------------------------------------
스프링 빈은 보통 싱글톤으로 컨테이너에 등록되는다. 이는 유일하게 해당 컨테이너 하나에 하나만 존재한다는 뜻이다. 
따라 new 를 하지 않는 이상 이미 존재하는 해당 빈이 불러와지게 된다.

스프링 빈이 좋은 이유 AOP 가 필요한 상황이 있을 수 있다.  -->  추후에 설명